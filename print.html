<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Casting Recursions Into Loops</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tc-rec-functions.html"><strong aria-hidden="true">2.</strong> Tail Call Recursive Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-tc.html"><strong aria-hidden="true">2.1.</strong> What is a Tail Call?</a></li><li class="chapter-item expanded "><a href="convert-to-tc.html"><strong aria-hidden="true">2.2.</strong> Converting non-Tail Call Recursion to Tail Call Recursion</a></li><li class="chapter-item expanded "><a href="tco.html"><strong aria-hidden="true">2.3.</strong> Tail Call Optimization/Elimination</a></li><li class="chapter-item expanded "><a href="convert-tc-to-loop.html"><strong aria-hidden="true">2.4.</strong> Converting Tail Call Recursions to Loops</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Casting Recursions Into Loops</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>&quot;Casting Recursions Into Loops&quot; is a book teaching how to convert recursive code
into loop code.</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Recursive code is a beautiful and simple way of expressing repetition, and to
some people, for some problems, it is the most natural way of doing so. However,
in languages like Rust, where stack overflow is a possibility, recursion is
limited to inputs small enough to prevent stack overflow. One could solve this
problem by converting recursion code to loop code.</p>
<h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<p>By recursion, we mean a function that calls itself in order to
implement repetition. In the following code, there is a classical example of
recursion, the factorial function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u128) -&gt; u128 {
    if n &lt; 2 {
        1
    } else {
        factorial(n - 1) * n
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Mutual recursion is a subtype of recursion in which a group of functions call
each other in order to implement repetition. In the following code, there is a
naive but fun implementation of &quot;is even&quot; and &quot;is odd&quot; functions that is
mutually recursive:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_even(n: u128) -&gt; bool {
    if n == 0 {
        true
    } else {
        is_odd(n - 1)
    }
}

fn is_odd(n: u128) -&gt; bool {
    if n == 0 {
        false
    } else {
        is_even(n - 1)
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>I'll assume most of you are comfortable with loops, but I will do a quick
recapitulation. Loops work by repeting a block of code until a given condition
is met. Rust has three types of loops: the one with a <code>loop</code> keyword, the one
with the <code>while</code> keyword, and the one with the <code>for</code> keyword. The <code>loop</code> loop
does not have a condition but can be stopped with a <code>break</code> keyword; the <code>while</code>
loop has a fixed condition; the <code>for</code> loop is a more dynamic loop, controlled by
an iterator object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-call-recursive-functions"><a class="header" href="#tail-call-recursive-functions">Tail Call Recursive Functions</a></h1>
<p>In this chapter we will see what is a tail function call, a function that is
tail call recursive, and how to convert them to loops. Finally, we'll see how to
convert some cases of non-tail call recursive functions into tail call recursive
ones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-tail-call"><a class="header" href="#what-is-a-tail-call">What is a Tail Call?</a></h1>
<p>A tail call is a function call that is the last thing the callee will execute.
In other words, if a function <code>F</code> calls a function <code>G</code>, such call is a tail call
if after calling <code>G</code>, <code>F</code> immediately returns; <code>return G()</code> is a tail call, but
<code>return G() * 3</code> is not a tail call, because after <code>G()</code> finishes, <code>F</code> still
needs to multiply the result by <code>3</code>.</p>
<h2 id="example-of-a-tail-call-recursive-function"><a class="header" href="#example-of-a-tail-call-recursive-function">Example of a Tail Call Recursive Function</a></h2>
<p>The following function is a recursive function that has the recursive call in
tail position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(m: u64, n: u64) -&gt; u64 {
    if m == 0 {
        n
    } else {
        add(m - 1, n + 1)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that after performing the recursive call, the result is returned unmodified
and the function will do nothing but return it immediately.</p>
<h2 id="counterexample-a-non-tail-call-recursive-function"><a class="header" href="#counterexample-a-non-tail-call-recursive-function">Counterexample: a Non-Tail Call Recursive Function</a></h2>
<p>The following function is a recursive function that does <strong>not</strong> have the
recursive call in tail position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(m: u64, n: u64) -&gt; u64 {
    if m == 0 {
        n
    } else {
        1 + add(m - 1, n)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>After performing the recursive call, the function needs to add <code>1</code> to the
result, therefore, it does not immediately return.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-non-tail-call-recursion-to-tail-call-recursion"><a class="header" href="#converting-non-tail-call-recursion-to-tail-call-recursion">Converting non-Tail Call Recursion to Tail Call Recursion</a></h1>
<p>Non-tail call recursions can sometimes be converted to tail call recursion. One
case is when the recursion performs a commutative operation, such as addition
and multiplication. Recall that a commutative operation is an operation whose
operands can be swapped and the result is not changed.</p>
<h2 id="recursion-performing-commutative-operations"><a class="header" href="#recursion-performing-commutative-operations">Recursion Performing Commutative Operations</a></h2>
<p>In this case, we are adding an additional argument storing the intermediate
result. As a studycase, consider the factorial function written in the following
way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: u128) -&gt; u128 {
    if n &lt;= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It can be rewritten as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial_impl(n: u128, acc: u128) -&gt; u128 {
    if n &lt;= 1 {
        acc
    } else {
        factorial_impl(n - 1, n * acc)
    }
}

fn factorial(n: u128) -&gt; u128 {
    factorial_impl(n, 1)
}
<span class="boring">}</span></code></pre></pre>
<p>Note:</p>
<ol>
<li>The additional accumulator argument.</li>
<li>The accumulator is returned in the base-case, and is propagated by recursive
callees, since the calls are tail calls.</li>
<li>And so, the actual computation happens in the arguments.</li>
<li>The multiplication order is reversed, but it does not matter, because
multiplication is commutative. Multiplication is reversed because what
happens is <code>((4 * 3) * 2) * 1</code> in the tail call version, while in the
non-tail call, what happens is <code>4 * (3 * (2 * 1))</code>.</li>
</ol>
<p>Another example we could explore is a function that finds the maximum element
of an array slice. Consider the following non-tail call recursion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max(slice: &amp;[u64]) -&gt; u64 {
    match slice.split_first() {
        None =&gt; 0,
        Some((x, xs)) =&gt; u64::max(*x, max(xs)),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It is not tail recursive function because after the recursive call, there is a
call to <code>u64::max</code>. Despite that, it is possible to make it tail recursive,
look at the following implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn max_impl(slice: &amp;[u64], acc: u64) -&gt; u64 {
    match slice.split_first() {
        None =&gt; acc,
        Some((x, xs)) =&gt; max(xs, u64::max(*x, acc)),
    }
}

fn max(slice: &amp;[u64]) -&gt; u64 {
    max_impl(slice, 0)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="thinking-of-parameters-as-variables-in-a-loop"><a class="header" href="#thinking-of-parameters-as-variables-in-a-loop">Thinking of Parameters as &quot;Variables&quot; in a Loop</a></h2>
<p>A more difficult case is this Fibonacci function implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fibonacci(n: u16) -&gt; u128 {
    if n &lt;= 1 {
        1
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The difficulty here is that this function has two recursive calls. However,
we can fix this by having two accumulators that interact with each other. Look
at this reimplementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fibonacci_impl(n: u16, curr: u128, next: u128) -&gt; u128 {
    if n == 0 {
        curr
    } else {
        fibonacci_impl(n - 1, next, curr + next)
    }
}

fn fibonacci(n: u16) -&gt; u128 {
    fibonacci_impl(n, 1, 1)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-call-optimizationelimination"><a class="header" href="#tail-call-optimizationelimination">Tail Call Optimization/Elimination</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-tail-call-recursions-to-loops"><a class="header" href="#converting-tail-call-recursions-to-loops">Converting Tail Call Recursions to Loops</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
